/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "mitro_api_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

#include "base/logging.h"

namespace mitro_api {


SignedRequest::~SignedRequest() throw() {
}


void SignedRequest::__set_transactionId(const std::string& val) {
  this->transactionId = val;
__isset.transactionId = true;
}

void SignedRequest::__set_request(const std::string& val) {
  this->request = val;
}

void SignedRequest::__set_signature(const std::string& val) {
  this->signature = val;
__isset.signature = true;
}

void SignedRequest::__set_identity(const std::string& val) {
  this->identity = val;
}

void SignedRequest::__set_clientIdentifier(const std::string& val) {
  this->clientIdentifier = val;
}

uint32_t SignedRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->request);
          this->__isset.request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->identity);
          this->__isset.identity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clientIdentifier);
          this->__isset.clientIdentifier = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SignedRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SignedRequest");

  if (this->__isset.transactionId) {
    xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->transactionId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->request);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.signature) {
    xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->signature);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("identity", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->identity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("clientIdentifier", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->clientIdentifier);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SignedRequest &a, SignedRequest &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.request, b.request);
  swap(a.signature, b.signature);
  swap(a.identity, b.identity);
  swap(a.clientIdentifier, b.clientIdentifier);
  swap(a.__isset, b.__isset);
}

SignedRequest::SignedRequest(const SignedRequest& other0) {
  transactionId = other0.transactionId;
  request = other0.request;
  signature = other0.signature;
  identity = other0.identity;
  clientIdentifier = other0.clientIdentifier;
  __isset = other0.__isset;
}
SignedRequest& SignedRequest::operator=(const SignedRequest& other1) {
  transactionId = other1.transactionId;
  request = other1.request;
  signature = other1.signature;
  identity = other1.identity;
  clientIdentifier = other1.clientIdentifier;
  __isset = other1.__isset;
  return *this;
}
void SignedRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SignedRequest(";
  out << "transactionId="; (__isset.transactionId ? (out << to_string(transactionId)) : (out << "<null>"));
  out << ", " << "request=" << to_string(request);
  out << ", " << "signature="; (__isset.signature ? (out << to_string(signature)) : (out << "<null>"));
  out << ", " << "identity=" << to_string(identity);
  out << ", " << "clientIdentifier=" << to_string(clientIdentifier);
  out << ")";
}


MitroException::~MitroException() throw() {
}


void MitroException::__set_exceptionId(const std::string& val) {
  this->exceptionId = val;
}

void MitroException::__set_stackTraceString(const std::string& val) {
  this->stackTraceString = val;
}

void MitroException::__set_rawMessage(const std::string& val) {
  this->rawMessage = val;
}

void MitroException::__set_userVisibleError(const std::string& val) {
  this->userVisibleError = val;
}

void MitroException::__set_exceptionType(const std::string& val) {
  this->exceptionType = val;
__isset.exceptionType = true;
}

uint32_t MitroException::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);

    LOG(INFO) << "fname: " << fname << " fid: " << fid;

    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->exceptionId);
          this->__isset.exceptionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stackTraceString);
          this->__isset.stackTraceString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rawMessage);
          this->__isset.rawMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userVisibleError);
          this->__isset.userVisibleError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        LOG(INFO) << "checking exception type" << std::endl;
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          LOG(INFO) << "setting exception type true" << std::endl;

          xfer += iprot->readString(this->exceptionType);
          this->__isset.exceptionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MitroException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MitroException");

  xfer += oprot->writeFieldBegin("exceptionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->exceptionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stackTraceString", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->stackTraceString);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rawMessage", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->rawMessage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userVisibleError", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->userVisibleError);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.exceptionType) {
    xfer += oprot->writeFieldBegin("exceptionType", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->exceptionType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MitroException &a, MitroException &b) {
  using ::std::swap;
  swap(a.exceptionId, b.exceptionId);
  swap(a.stackTraceString, b.stackTraceString);
  swap(a.rawMessage, b.rawMessage);
  swap(a.userVisibleError, b.userVisibleError);
  swap(a.exceptionType, b.exceptionType);
  swap(a.__isset, b.__isset);
}

MitroException::MitroException(const MitroException& other2) {
  exceptionId = other2.exceptionId;
  stackTraceString = other2.stackTraceString;
  rawMessage = other2.rawMessage;
  userVisibleError = other2.userVisibleError;
  exceptionType = other2.exceptionType;
  __isset = other2.__isset;
}
MitroException& MitroException::operator=(const MitroException& other3) {
  exceptionId = other3.exceptionId;
  stackTraceString = other3.stackTraceString;
  rawMessage = other3.rawMessage;
  userVisibleError = other3.userVisibleError;
  exceptionType = other3.exceptionType;
  __isset = other3.__isset;
  return *this;
}
void MitroException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MitroException(";
  out << "exceptionId=" << to_string(exceptionId);
  out << ", " << "stackTraceString=" << to_string(stackTraceString);
  out << ", " << "rawMessage=" << to_string(rawMessage);
  out << ", " << "userVisibleError=" << to_string(userVisibleError);
  out << ", " << "exceptionType="; (__isset.exceptionType ? (out << to_string(exceptionType)) : (out << "<null>"));
  out << ")";
}


MitroRPC::~MitroRPC() throw() {
}


void MitroRPC::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void MitroRPC::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

uint32_t MitroRPC::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MitroRPC::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MitroRPC");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MitroRPC &a, MitroRPC &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.__isset, b.__isset);
}

MitroRPC::MitroRPC(const MitroRPC& other4) {
  transactionId = other4.transactionId;
  deviceId = other4.deviceId;
  __isset = other4.__isset;
}
MitroRPC& MitroRPC::operator=(const MitroRPC& other5) {
  transactionId = other5.transactionId;
  deviceId = other5.deviceId;
  __isset = other5.__isset;
  return *this;
}
void MitroRPC::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MitroRPC(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ")";
}


GetMyPrivateKeyRequest::~GetMyPrivateKeyRequest() throw() {
}


void GetMyPrivateKeyRequest::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void GetMyPrivateKeyRequest::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void GetMyPrivateKeyRequest::__set_userId(const std::string& val) {
  this->userId = val;
}

void GetMyPrivateKeyRequest::__set_loginToken(const std::string& val) {
  this->loginToken = val;
}

void GetMyPrivateKeyRequest::__set_loginTokenSignature(const std::string& val) {
  this->loginTokenSignature = val;
}

void GetMyPrivateKeyRequest::__set_extensionId(const std::string& val) {
  this->extensionId = val;
}

void GetMyPrivateKeyRequest::__set_twoFactorCode(const std::string& val) {
  this->twoFactorCode = val;
}

uint32_t GetMyPrivateKeyRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userId);
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->loginToken);
          this->__isset.loginToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->loginTokenSignature);
          this->__isset.loginTokenSignature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->extensionId);
          this->__isset.extensionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->twoFactorCode);
          this->__isset.twoFactorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetMyPrivateKeyRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetMyPrivateKeyRequest");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("loginToken", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->loginToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("loginTokenSignature", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->loginTokenSignature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extensionId", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->extensionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("twoFactorCode", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->twoFactorCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetMyPrivateKeyRequest &a, GetMyPrivateKeyRequest &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.userId, b.userId);
  swap(a.loginToken, b.loginToken);
  swap(a.loginTokenSignature, b.loginTokenSignature);
  swap(a.extensionId, b.extensionId);
  swap(a.twoFactorCode, b.twoFactorCode);
  swap(a.__isset, b.__isset);
}

GetMyPrivateKeyRequest::GetMyPrivateKeyRequest(const GetMyPrivateKeyRequest& other6) {
  transactionId = other6.transactionId;
  deviceId = other6.deviceId;
  userId = other6.userId;
  loginToken = other6.loginToken;
  loginTokenSignature = other6.loginTokenSignature;
  extensionId = other6.extensionId;
  twoFactorCode = other6.twoFactorCode;
  __isset = other6.__isset;
}
GetMyPrivateKeyRequest& GetMyPrivateKeyRequest::operator=(const GetMyPrivateKeyRequest& other7) {
  transactionId = other7.transactionId;
  deviceId = other7.deviceId;
  userId = other7.userId;
  loginToken = other7.loginToken;
  loginTokenSignature = other7.loginTokenSignature;
  extensionId = other7.extensionId;
  twoFactorCode = other7.twoFactorCode;
  __isset = other7.__isset;
  return *this;
}
void GetMyPrivateKeyRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetMyPrivateKeyRequest(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "userId=" << to_string(userId);
  out << ", " << "loginToken=" << to_string(loginToken);
  out << ", " << "loginTokenSignature=" << to_string(loginTokenSignature);
  out << ", " << "extensionId=" << to_string(extensionId);
  out << ", " << "twoFactorCode=" << to_string(twoFactorCode);
  out << ")";
}


GetMyPrivateKeyResponse::~GetMyPrivateKeyResponse() throw() {
}


void GetMyPrivateKeyResponse::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void GetMyPrivateKeyResponse::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void GetMyPrivateKeyResponse::__set_myUserId(const std::string& val) {
  this->myUserId = val;
}

void GetMyPrivateKeyResponse::__set_encryptedPrivateKey(const std::string& val) {
  this->encryptedPrivateKey = val;
__isset.encryptedPrivateKey = true;
}

void GetMyPrivateKeyResponse::__set_changePasswordOnNextLogin(const bool val) {
  this->changePasswordOnNextLogin = val;
}

void GetMyPrivateKeyResponse::__set_verified(const bool val) {
  this->verified = val;
}

void GetMyPrivateKeyResponse::__set_unsignedLoginToken(const std::string& val) {
  this->unsignedLoginToken = val;
}

void GetMyPrivateKeyResponse::__set_deviceKeyString(const std::string& val) {
  this->deviceKeyString = val;
__isset.deviceKeyString = true;
}

uint32_t GetMyPrivateKeyResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->myUserId);
          this->__isset.myUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->encryptedPrivateKey);
          this->__isset.encryptedPrivateKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->changePasswordOnNextLogin);
          this->__isset.changePasswordOnNextLogin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->verified);
          this->__isset.verified = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unsignedLoginToken);
          this->__isset.unsignedLoginToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceKeyString);
          this->__isset.deviceKeyString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetMyPrivateKeyResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetMyPrivateKeyResponse");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("myUserId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->myUserId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encryptedPrivateKey) {
    xfer += oprot->writeFieldBegin("encryptedPrivateKey", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->encryptedPrivateKey);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("changePasswordOnNextLogin", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->changePasswordOnNextLogin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("verified", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->verified);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unsignedLoginToken", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->unsignedLoginToken);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.deviceKeyString) {
    xfer += oprot->writeFieldBegin("deviceKeyString", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->deviceKeyString);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetMyPrivateKeyResponse &a, GetMyPrivateKeyResponse &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.myUserId, b.myUserId);
  swap(a.encryptedPrivateKey, b.encryptedPrivateKey);
  swap(a.changePasswordOnNextLogin, b.changePasswordOnNextLogin);
  swap(a.verified, b.verified);
  swap(a.unsignedLoginToken, b.unsignedLoginToken);
  swap(a.deviceKeyString, b.deviceKeyString);
  swap(a.__isset, b.__isset);
}

GetMyPrivateKeyResponse::GetMyPrivateKeyResponse(const GetMyPrivateKeyResponse& other8) {
  transactionId = other8.transactionId;
  deviceId = other8.deviceId;
  myUserId = other8.myUserId;
  encryptedPrivateKey = other8.encryptedPrivateKey;
  changePasswordOnNextLogin = other8.changePasswordOnNextLogin;
  verified = other8.verified;
  unsignedLoginToken = other8.unsignedLoginToken;
  deviceKeyString = other8.deviceKeyString;
  __isset = other8.__isset;
}
GetMyPrivateKeyResponse& GetMyPrivateKeyResponse::operator=(const GetMyPrivateKeyResponse& other9) {
  transactionId = other9.transactionId;
  deviceId = other9.deviceId;
  myUserId = other9.myUserId;
  encryptedPrivateKey = other9.encryptedPrivateKey;
  changePasswordOnNextLogin = other9.changePasswordOnNextLogin;
  verified = other9.verified;
  unsignedLoginToken = other9.unsignedLoginToken;
  deviceKeyString = other9.deviceKeyString;
  __isset = other9.__isset;
  return *this;
}
void GetMyPrivateKeyResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetMyPrivateKeyResponse(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "myUserId=" << to_string(myUserId);
  out << ", " << "encryptedPrivateKey="; (__isset.encryptedPrivateKey ? (out << to_string(encryptedPrivateKey)) : (out << "<null>"));
  out << ", " << "changePasswordOnNextLogin=" << to_string(changePasswordOnNextLogin);
  out << ", " << "verified=" << to_string(verified);
  out << ", " << "unsignedLoginToken=" << to_string(unsignedLoginToken);
  out << ", " << "deviceKeyString="; (__isset.deviceKeyString ? (out << to_string(deviceKeyString)) : (out << "<null>"));
  out << ")";
}


CheckTwoFactorRequiredRequest::~CheckTwoFactorRequiredRequest() throw() {
}


void CheckTwoFactorRequiredRequest::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void CheckTwoFactorRequiredRequest::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void CheckTwoFactorRequiredRequest::__set_extensionId(const std::string& val) {
  this->extensionId = val;
}

uint32_t CheckTwoFactorRequiredRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->extensionId);
          this->__isset.extensionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CheckTwoFactorRequiredRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CheckTwoFactorRequiredRequest");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extensionId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->extensionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CheckTwoFactorRequiredRequest &a, CheckTwoFactorRequiredRequest &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.extensionId, b.extensionId);
  swap(a.__isset, b.__isset);
}

CheckTwoFactorRequiredRequest::CheckTwoFactorRequiredRequest(const CheckTwoFactorRequiredRequest& other10) {
  transactionId = other10.transactionId;
  deviceId = other10.deviceId;
  extensionId = other10.extensionId;
  __isset = other10.__isset;
}
CheckTwoFactorRequiredRequest& CheckTwoFactorRequiredRequest::operator=(const CheckTwoFactorRequiredRequest& other11) {
  transactionId = other11.transactionId;
  deviceId = other11.deviceId;
  extensionId = other11.extensionId;
  __isset = other11.__isset;
  return *this;
}
void CheckTwoFactorRequiredRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CheckTwoFactorRequiredRequest(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "extensionId=" << to_string(extensionId);
  out << ")";
}


CheckTwoFactorRequiredResponse::~CheckTwoFactorRequiredResponse() throw() {
}


void CheckTwoFactorRequiredResponse::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void CheckTwoFactorRequiredResponse::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void CheckTwoFactorRequiredResponse::__set_twoFactorUrl(const std::string& val) {
  this->twoFactorUrl = val;
}

uint32_t CheckTwoFactorRequiredResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->twoFactorUrl);
          this->__isset.twoFactorUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CheckTwoFactorRequiredResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CheckTwoFactorRequiredResponse");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("twoFactorUrl", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->twoFactorUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CheckTwoFactorRequiredResponse &a, CheckTwoFactorRequiredResponse &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.twoFactorUrl, b.twoFactorUrl);
  swap(a.__isset, b.__isset);
}

CheckTwoFactorRequiredResponse::CheckTwoFactorRequiredResponse(const CheckTwoFactorRequiredResponse& other12) {
  transactionId = other12.transactionId;
  deviceId = other12.deviceId;
  twoFactorUrl = other12.twoFactorUrl;
  __isset = other12.__isset;
}
CheckTwoFactorRequiredResponse& CheckTwoFactorRequiredResponse::operator=(const CheckTwoFactorRequiredResponse& other13) {
  transactionId = other13.transactionId;
  deviceId = other13.deviceId;
  twoFactorUrl = other13.twoFactorUrl;
  __isset = other13.__isset;
  return *this;
}
void CheckTwoFactorRequiredResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CheckTwoFactorRequiredResponse(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "twoFactorUrl=" << to_string(twoFactorUrl);
  out << ")";
}


GetMyDeviceKeyResponse::~GetMyDeviceKeyResponse() throw() {
}


void GetMyDeviceKeyResponse::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void GetMyDeviceKeyResponse::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void GetMyDeviceKeyResponse::__set_deviceKeyString(const std::string& val) {
  this->deviceKeyString = val;
}

uint32_t GetMyDeviceKeyResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceKeyString);
          this->__isset.deviceKeyString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetMyDeviceKeyResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetMyDeviceKeyResponse");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceKeyString", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->deviceKeyString);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetMyDeviceKeyResponse &a, GetMyDeviceKeyResponse &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.deviceKeyString, b.deviceKeyString);
  swap(a.__isset, b.__isset);
}

GetMyDeviceKeyResponse::GetMyDeviceKeyResponse(const GetMyDeviceKeyResponse& other14) {
  transactionId = other14.transactionId;
  deviceId = other14.deviceId;
  deviceKeyString = other14.deviceKeyString;
  __isset = other14.__isset;
}
GetMyDeviceKeyResponse& GetMyDeviceKeyResponse::operator=(const GetMyDeviceKeyResponse& other15) {
  transactionId = other15.transactionId;
  deviceId = other15.deviceId;
  deviceKeyString = other15.deviceKeyString;
  __isset = other15.__isset;
  return *this;
}
void GetMyDeviceKeyResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetMyDeviceKeyResponse(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "deviceKeyString=" << to_string(deviceKeyString);
  out << ")";
}


SecretClientData::~SecretClientData() throw() {
}


void SecretClientData::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void SecretClientData::__set_loginUrl(const std::string& val) {
  this->loginUrl = val;
__isset.loginUrl = true;
}

void SecretClientData::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void SecretClientData::__set_usernameField(const std::string& val) {
  this->usernameField = val;
__isset.usernameField = true;
}

void SecretClientData::__set_passwordField(const std::string& val) {
  this->passwordField = val;
__isset.passwordField = true;
}

void SecretClientData::__set_title(const std::string& val) {
  this->title = val;
__isset.title = true;
}

uint32_t SecretClientData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->loginUrl);
          this->__isset.loginUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->usernameField);
          this->__isset.usernameField = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->passwordField);
          this->__isset.passwordField = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SecretClientData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SecretClientData");

  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.loginUrl) {
    xfer += oprot->writeFieldBegin("loginUrl", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->loginUrl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.usernameField) {
    xfer += oprot->writeFieldBegin("usernameField", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->usernameField);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.passwordField) {
    xfer += oprot->writeFieldBegin("passwordField", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->passwordField);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.title) {
    xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->title);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SecretClientData &a, SecretClientData &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.loginUrl, b.loginUrl);
  swap(a.username, b.username);
  swap(a.usernameField, b.usernameField);
  swap(a.passwordField, b.passwordField);
  swap(a.title, b.title);
  swap(a.__isset, b.__isset);
}

SecretClientData::SecretClientData(const SecretClientData& other16) {
  type = other16.type;
  loginUrl = other16.loginUrl;
  username = other16.username;
  usernameField = other16.usernameField;
  passwordField = other16.passwordField;
  title = other16.title;
  __isset = other16.__isset;
}
SecretClientData& SecretClientData::operator=(const SecretClientData& other17) {
  type = other17.type;
  loginUrl = other17.loginUrl;
  username = other17.username;
  usernameField = other17.usernameField;
  passwordField = other17.passwordField;
  title = other17.title;
  __isset = other17.__isset;
  return *this;
}
void SecretClientData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SecretClientData(";
  out << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "loginUrl="; (__isset.loginUrl ? (out << to_string(loginUrl)) : (out << "<null>"));
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "usernameField="; (__isset.usernameField ? (out << to_string(usernameField)) : (out << "<null>"));
  out << ", " << "passwordField="; (__isset.passwordField ? (out << to_string(passwordField)) : (out << "<null>"));
  out << ", " << "title="; (__isset.title ? (out << to_string(title)) : (out << "<null>"));
  out << ")";
}


SecretCriticalData::~SecretCriticalData() throw() {
}


void SecretCriticalData::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void SecretCriticalData::__set_note(const std::string& val) {
  this->note = val;
__isset.note = true;
}

uint32_t SecretCriticalData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->note);
          this->__isset.note = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SecretCriticalData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SecretCriticalData");

  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.note) {
    xfer += oprot->writeFieldBegin("note", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->note);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SecretCriticalData &a, SecretCriticalData &b) {
  using ::std::swap;
  swap(a.password, b.password);
  swap(a.note, b.note);
  swap(a.__isset, b.__isset);
}

SecretCriticalData::SecretCriticalData(const SecretCriticalData& other18) {
  password = other18.password;
  note = other18.note;
  __isset = other18.__isset;
}
SecretCriticalData& SecretCriticalData::operator=(const SecretCriticalData& other19) {
  password = other19.password;
  note = other19.note;
  __isset = other19.__isset;
  return *this;
}
void SecretCriticalData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SecretCriticalData(";
  out << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "note="; (__isset.note ? (out << to_string(note)) : (out << "<null>"));
  out << ")";
}


Secret::~Secret() throw() {
}


void Secret::__set_secretId(const int32_t val) {
  this->secretId = val;
__isset.secretId = true;
}

void Secret::__set_hostname(const std::string& val) {
  this->hostname = val;
__isset.hostname = true;
}

void Secret::__set_encryptedClientData(const std::string& val) {
  this->encryptedClientData = val;
__isset.encryptedClientData = true;
}

void Secret::__set_encryptedCriticalData(const std::string& val) {
  this->encryptedCriticalData = val;
__isset.encryptedCriticalData = true;
}

void Secret::__set_groups(const std::vector<int32_t> & val) {
  this->groups = val;
__isset.groups = true;
}

void Secret::__set_hiddenGroups(const std::vector<int32_t> & val) {
  this->hiddenGroups = val;
__isset.hiddenGroups = true;
}

void Secret::__set_users(const std::vector<std::string> & val) {
  this->users = val;
__isset.users = true;
}

void Secret::__set_icons(const std::vector<std::string> & val) {
  this->icons = val;
__isset.icons = true;
}

void Secret::__set_groupNames(const std::map<std::string, std::string> & val) {
  this->groupNames = val;
__isset.groupNames = true;
}

void Secret::__set_title(const std::string& val) {
  this->title = val;
__isset.title = true;
}

void Secret::__set_groupIdPath(const std::vector<int32_t> & val) {
  this->groupIdPath = val;
__isset.groupIdPath = true;
}

void Secret::__set_clientData(const SecretClientData& val) {
  this->clientData = val;
__isset.clientData = true;
}

void Secret::__set_criticalData(const SecretCriticalData& val) {
  this->criticalData = val;
__isset.criticalData = true;
}

uint32_t Secret::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->secretId);
          this->__isset.secretId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          this->__isset.hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->encryptedClientData);
          this->__isset.encryptedClientData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->encryptedCriticalData);
          this->__isset.encryptedCriticalData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->groups.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->groups.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += iprot->readI32(this->groups[_i24]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->hiddenGroups.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->hiddenGroups.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += iprot->readI32(this->hiddenGroups[_i29]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.hiddenGroups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->users.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->users.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += iprot->readString(this->users[_i34]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.users = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->icons.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->icons.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += iprot->readString(this->icons[_i39]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.icons = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->groupNames.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _ktype41;
            ::apache::thrift::protocol::TType _vtype42;
            xfer += iprot->readMapBegin(_ktype41, _vtype42, _size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              std::string _key45;
              xfer += iprot->readString(_key45);
              std::string& _val46 = this->groupNames[_key45];
              xfer += iprot->readString(_val46);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.groupNames = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->groupIdPath.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->groupIdPath.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += iprot->readI32(this->groupIdPath[_i51]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.groupIdPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->clientData.read(iprot);
          this->__isset.clientData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->criticalData.read(iprot);
          this->__isset.criticalData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Secret::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Secret");

  if (this->__isset.secretId) {
    xfer += oprot->writeFieldBegin("secretId", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->secretId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hostname) {
    xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->hostname);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encryptedClientData) {
    xfer += oprot->writeFieldBegin("encryptedClientData", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->encryptedClientData);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encryptedCriticalData) {
    xfer += oprot->writeFieldBegin("encryptedCriticalData", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->encryptedCriticalData);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.groups) {
    xfer += oprot->writeFieldBegin("groups", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->groups.size()));
      std::vector<int32_t> ::const_iterator _iter52;
      for (_iter52 = this->groups.begin(); _iter52 != this->groups.end(); ++_iter52)
      {
        xfer += oprot->writeI32((*_iter52));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.hiddenGroups) {
    xfer += oprot->writeFieldBegin("hiddenGroups", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->hiddenGroups.size()));
      std::vector<int32_t> ::const_iterator _iter53;
      for (_iter53 = this->hiddenGroups.begin(); _iter53 != this->hiddenGroups.end(); ++_iter53)
      {
        xfer += oprot->writeI32((*_iter53));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.users) {
    xfer += oprot->writeFieldBegin("users", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->users.size()));
      std::vector<std::string> ::const_iterator _iter54;
      for (_iter54 = this->users.begin(); _iter54 != this->users.end(); ++_iter54)
      {
        xfer += oprot->writeString((*_iter54));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.icons) {
    xfer += oprot->writeFieldBegin("icons", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->icons.size()));
      std::vector<std::string> ::const_iterator _iter55;
      for (_iter55 = this->icons.begin(); _iter55 != this->icons.end(); ++_iter55)
      {
        xfer += oprot->writeString((*_iter55));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.groupNames) {
    xfer += oprot->writeFieldBegin("groupNames", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->groupNames.size()));
      std::map<std::string, std::string> ::const_iterator _iter56;
      for (_iter56 = this->groupNames.begin(); _iter56 != this->groupNames.end(); ++_iter56)
      {
        xfer += oprot->writeString(_iter56->first);
        xfer += oprot->writeString(_iter56->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.title) {
    xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 10);
    xfer += oprot->writeString(this->title);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.groupIdPath) {
    xfer += oprot->writeFieldBegin("groupIdPath", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->groupIdPath.size()));
      std::vector<int32_t> ::const_iterator _iter57;
      for (_iter57 = this->groupIdPath.begin(); _iter57 != this->groupIdPath.end(); ++_iter57)
      {
        xfer += oprot->writeI32((*_iter57));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clientData) {
    xfer += oprot->writeFieldBegin("clientData", ::apache::thrift::protocol::T_STRUCT, 12);
    xfer += this->clientData.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.criticalData) {
    xfer += oprot->writeFieldBegin("criticalData", ::apache::thrift::protocol::T_STRUCT, 13);
    xfer += this->criticalData.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Secret &a, Secret &b) {
  using ::std::swap;
  swap(a.secretId, b.secretId);
  swap(a.hostname, b.hostname);
  swap(a.encryptedClientData, b.encryptedClientData);
  swap(a.encryptedCriticalData, b.encryptedCriticalData);
  swap(a.groups, b.groups);
  swap(a.hiddenGroups, b.hiddenGroups);
  swap(a.users, b.users);
  swap(a.icons, b.icons);
  swap(a.groupNames, b.groupNames);
  swap(a.title, b.title);
  swap(a.groupIdPath, b.groupIdPath);
  swap(a.clientData, b.clientData);
  swap(a.criticalData, b.criticalData);
  swap(a.__isset, b.__isset);
}

Secret::Secret(const Secret& other58) {
  secretId = other58.secretId;
  hostname = other58.hostname;
  encryptedClientData = other58.encryptedClientData;
  encryptedCriticalData = other58.encryptedCriticalData;
  groups = other58.groups;
  hiddenGroups = other58.hiddenGroups;
  users = other58.users;
  icons = other58.icons;
  groupNames = other58.groupNames;
  title = other58.title;
  groupIdPath = other58.groupIdPath;
  clientData = other58.clientData;
  criticalData = other58.criticalData;
  __isset = other58.__isset;
}
Secret& Secret::operator=(const Secret& other59) {
  secretId = other59.secretId;
  hostname = other59.hostname;
  encryptedClientData = other59.encryptedClientData;
  encryptedCriticalData = other59.encryptedCriticalData;
  groups = other59.groups;
  hiddenGroups = other59.hiddenGroups;
  users = other59.users;
  icons = other59.icons;
  groupNames = other59.groupNames;
  title = other59.title;
  groupIdPath = other59.groupIdPath;
  clientData = other59.clientData;
  criticalData = other59.criticalData;
  __isset = other59.__isset;
  return *this;
}
void Secret::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Secret(";
  out << "secretId="; (__isset.secretId ? (out << to_string(secretId)) : (out << "<null>"));
  out << ", " << "hostname="; (__isset.hostname ? (out << to_string(hostname)) : (out << "<null>"));
  out << ", " << "encryptedClientData="; (__isset.encryptedClientData ? (out << to_string(encryptedClientData)) : (out << "<null>"));
  out << ", " << "encryptedCriticalData="; (__isset.encryptedCriticalData ? (out << to_string(encryptedCriticalData)) : (out << "<null>"));
  out << ", " << "groups="; (__isset.groups ? (out << to_string(groups)) : (out << "<null>"));
  out << ", " << "hiddenGroups="; (__isset.hiddenGroups ? (out << to_string(hiddenGroups)) : (out << "<null>"));
  out << ", " << "users="; (__isset.users ? (out << to_string(users)) : (out << "<null>"));
  out << ", " << "icons="; (__isset.icons ? (out << to_string(icons)) : (out << "<null>"));
  out << ", " << "groupNames="; (__isset.groupNames ? (out << to_string(groupNames)) : (out << "<null>"));
  out << ", " << "title="; (__isset.title ? (out << to_string(title)) : (out << "<null>"));
  out << ", " << "groupIdPath="; (__isset.groupIdPath ? (out << to_string(groupIdPath)) : (out << "<null>"));
  out << ", " << "clientData="; (__isset.clientData ? (out << to_string(clientData)) : (out << "<null>"));
  out << ", " << "criticalData="; (__isset.criticalData ? (out << to_string(criticalData)) : (out << "<null>"));
  out << ")";
}


GroupInfo::~GroupInfo() throw() {
}


void GroupInfo::__set_groupId(const int32_t val) {
  this->groupId = val;
}

void GroupInfo::__set_autoDelete(const bool val) {
  this->autoDelete = val;
}

void GroupInfo::__set_name(const std::string& val) {
  this->name = val;
}

void GroupInfo::__set_encryptedPrivateKey(const std::string& val) {
  this->encryptedPrivateKey = val;
}

uint32_t GroupInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->groupId);
          this->__isset.groupId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->autoDelete);
          this->__isset.autoDelete = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->encryptedPrivateKey);
          this->__isset.encryptedPrivateKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GroupInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GroupInfo");

  xfer += oprot->writeFieldBegin("groupId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->groupId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("autoDelete", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->autoDelete);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encryptedPrivateKey", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->encryptedPrivateKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GroupInfo &a, GroupInfo &b) {
  using ::std::swap;
  swap(a.groupId, b.groupId);
  swap(a.autoDelete, b.autoDelete);
  swap(a.name, b.name);
  swap(a.encryptedPrivateKey, b.encryptedPrivateKey);
  swap(a.__isset, b.__isset);
}

GroupInfo::GroupInfo(const GroupInfo& other60) {
  groupId = other60.groupId;
  autoDelete = other60.autoDelete;
  name = other60.name;
  encryptedPrivateKey = other60.encryptedPrivateKey;
  __isset = other60.__isset;
}
GroupInfo& GroupInfo::operator=(const GroupInfo& other61) {
  groupId = other61.groupId;
  autoDelete = other61.autoDelete;
  name = other61.name;
  encryptedPrivateKey = other61.encryptedPrivateKey;
  __isset = other61.__isset;
  return *this;
}
void GroupInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GroupInfo(";
  out << "groupId=" << to_string(groupId);
  out << ", " << "autoDelete=" << to_string(autoDelete);
  out << ", " << "name=" << to_string(name);
  out << ", " << "encryptedPrivateKey=" << to_string(encryptedPrivateKey);
  out << ")";
}


ListMySecretsAndGroupKeysRequest::~ListMySecretsAndGroupKeysRequest() throw() {
}


void ListMySecretsAndGroupKeysRequest::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void ListMySecretsAndGroupKeysRequest::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void ListMySecretsAndGroupKeysRequest::__set_myUserId(const std::string& val) {
  this->myUserId = val;
__isset.myUserId = true;
}

uint32_t ListMySecretsAndGroupKeysRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->myUserId);
          this->__isset.myUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListMySecretsAndGroupKeysRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListMySecretsAndGroupKeysRequest");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.myUserId) {
    xfer += oprot->writeFieldBegin("myUserId", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->myUserId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListMySecretsAndGroupKeysRequest &a, ListMySecretsAndGroupKeysRequest &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.myUserId, b.myUserId);
  swap(a.__isset, b.__isset);
}

ListMySecretsAndGroupKeysRequest::ListMySecretsAndGroupKeysRequest(const ListMySecretsAndGroupKeysRequest& other62) {
  transactionId = other62.transactionId;
  deviceId = other62.deviceId;
  myUserId = other62.myUserId;
  __isset = other62.__isset;
}
ListMySecretsAndGroupKeysRequest& ListMySecretsAndGroupKeysRequest::operator=(const ListMySecretsAndGroupKeysRequest& other63) {
  transactionId = other63.transactionId;
  deviceId = other63.deviceId;
  myUserId = other63.myUserId;
  __isset = other63.__isset;
  return *this;
}
void ListMySecretsAndGroupKeysRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListMySecretsAndGroupKeysRequest(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "myUserId="; (__isset.myUserId ? (out << to_string(myUserId)) : (out << "<null>"));
  out << ")";
}


ListMySecretsAndGroupKeysResponse::~ListMySecretsAndGroupKeysResponse() throw() {
}


void ListMySecretsAndGroupKeysResponse::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void ListMySecretsAndGroupKeysResponse::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void ListMySecretsAndGroupKeysResponse::__set_myUserId(const std::string& val) {
  this->myUserId = val;
}

void ListMySecretsAndGroupKeysResponse::__set_secretToPath(const std::map<std::string, Secret> & val) {
  this->secretToPath = val;
}

void ListMySecretsAndGroupKeysResponse::__set_groups(const std::map<std::string, GroupInfo> & val) {
  this->groups = val;
}

void ListMySecretsAndGroupKeysResponse::__set_autocompleteUsers(const std::vector<std::string> & val) {
  this->autocompleteUsers = val;
}

uint32_t ListMySecretsAndGroupKeysResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->myUserId);
          this->__isset.myUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->secretToPath.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _ktype65;
            ::apache::thrift::protocol::TType _vtype66;
            xfer += iprot->readMapBegin(_ktype65, _vtype66, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              std::string _key69;
              xfer += iprot->readString(_key69);
              Secret& _val70 = this->secretToPath[_key69];
              xfer += _val70.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.secretToPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->groups.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _ktype72;
            ::apache::thrift::protocol::TType _vtype73;
            xfer += iprot->readMapBegin(_ktype72, _vtype73, _size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              std::string _key76;
              xfer += iprot->readString(_key76);
              GroupInfo& _val77 = this->groups[_key76];
              xfer += _val77.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->autocompleteUsers.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->autocompleteUsers.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += iprot->readString(this->autocompleteUsers[_i82]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.autocompleteUsers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListMySecretsAndGroupKeysResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListMySecretsAndGroupKeysResponse");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("myUserId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->myUserId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secretToPath", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->secretToPath.size()));
    std::map<std::string, Secret> ::const_iterator _iter83;
    for (_iter83 = this->secretToPath.begin(); _iter83 != this->secretToPath.end(); ++_iter83)
    {
      xfer += oprot->writeString(_iter83->first);
      xfer += _iter83->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groups", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->groups.size()));
    std::map<std::string, GroupInfo> ::const_iterator _iter84;
    for (_iter84 = this->groups.begin(); _iter84 != this->groups.end(); ++_iter84)
    {
      xfer += oprot->writeString(_iter84->first);
      xfer += _iter84->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("autocompleteUsers", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->autocompleteUsers.size()));
    std::vector<std::string> ::const_iterator _iter85;
    for (_iter85 = this->autocompleteUsers.begin(); _iter85 != this->autocompleteUsers.end(); ++_iter85)
    {
      xfer += oprot->writeString((*_iter85));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListMySecretsAndGroupKeysResponse &a, ListMySecretsAndGroupKeysResponse &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.myUserId, b.myUserId);
  swap(a.secretToPath, b.secretToPath);
  swap(a.groups, b.groups);
  swap(a.autocompleteUsers, b.autocompleteUsers);
  swap(a.__isset, b.__isset);
}

ListMySecretsAndGroupKeysResponse::ListMySecretsAndGroupKeysResponse(const ListMySecretsAndGroupKeysResponse& other86) {
  transactionId = other86.transactionId;
  deviceId = other86.deviceId;
  myUserId = other86.myUserId;
  secretToPath = other86.secretToPath;
  groups = other86.groups;
  autocompleteUsers = other86.autocompleteUsers;
  __isset = other86.__isset;
}
ListMySecretsAndGroupKeysResponse& ListMySecretsAndGroupKeysResponse::operator=(const ListMySecretsAndGroupKeysResponse& other87) {
  transactionId = other87.transactionId;
  deviceId = other87.deviceId;
  myUserId = other87.myUserId;
  secretToPath = other87.secretToPath;
  groups = other87.groups;
  autocompleteUsers = other87.autocompleteUsers;
  __isset = other87.__isset;
  return *this;
}
void ListMySecretsAndGroupKeysResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListMySecretsAndGroupKeysResponse(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "myUserId=" << to_string(myUserId);
  out << ", " << "secretToPath=" << to_string(secretToPath);
  out << ", " << "groups=" << to_string(groups);
  out << ", " << "autocompleteUsers=" << to_string(autocompleteUsers);
  out << ")";
}


GetSecretRequest::~GetSecretRequest() throw() {
}


void GetSecretRequest::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void GetSecretRequest::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void GetSecretRequest::__set_userId(const std::string& val) {
  this->userId = val;
}

void GetSecretRequest::__set_secretId(const int32_t val) {
  this->secretId = val;
}

void GetSecretRequest::__set_groupId(const int32_t val) {
  this->groupId = val;
}

void GetSecretRequest::__set_includeCriticalData(const bool val) {
  this->includeCriticalData = val;
}

uint32_t GetSecretRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userId);
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->secretId);
          this->__isset.secretId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->groupId);
          this->__isset.groupId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->includeCriticalData);
          this->__isset.includeCriticalData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetSecretRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetSecretRequest");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secretId", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->secretId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupId", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->groupId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("includeCriticalData", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->includeCriticalData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetSecretRequest &a, GetSecretRequest &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.userId, b.userId);
  swap(a.secretId, b.secretId);
  swap(a.groupId, b.groupId);
  swap(a.includeCriticalData, b.includeCriticalData);
  swap(a.__isset, b.__isset);
}

GetSecretRequest::GetSecretRequest(const GetSecretRequest& other88) {
  transactionId = other88.transactionId;
  deviceId = other88.deviceId;
  userId = other88.userId;
  secretId = other88.secretId;
  groupId = other88.groupId;
  includeCriticalData = other88.includeCriticalData;
  __isset = other88.__isset;
}
GetSecretRequest& GetSecretRequest::operator=(const GetSecretRequest& other89) {
  transactionId = other89.transactionId;
  deviceId = other89.deviceId;
  userId = other89.userId;
  secretId = other89.secretId;
  groupId = other89.groupId;
  includeCriticalData = other89.includeCriticalData;
  __isset = other89.__isset;
  return *this;
}
void GetSecretRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetSecretRequest(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "userId=" << to_string(userId);
  out << ", " << "secretId=" << to_string(secretId);
  out << ", " << "groupId=" << to_string(groupId);
  out << ", " << "includeCriticalData=" << to_string(includeCriticalData);
  out << ")";
}


GetSecretResponse::~GetSecretResponse() throw() {
}


void GetSecretResponse::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void GetSecretResponse::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void GetSecretResponse::__set_secret(const Secret& val) {
  this->secret = val;
}

uint32_t GetSecretResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->secret.read(iprot);
          this->__isset.secret = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetSecretResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetSecretResponse");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secret", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->secret.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetSecretResponse &a, GetSecretResponse &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.secret, b.secret);
  swap(a.__isset, b.__isset);
}

GetSecretResponse::GetSecretResponse(const GetSecretResponse& other90) {
  transactionId = other90.transactionId;
  deviceId = other90.deviceId;
  secret = other90.secret;
  __isset = other90.__isset;
}
GetSecretResponse& GetSecretResponse::operator=(const GetSecretResponse& other91) {
  transactionId = other91.transactionId;
  deviceId = other91.deviceId;
  secret = other91.secret;
  __isset = other91.__isset;
  return *this;
}
void GetSecretResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetSecretResponse(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "secret=" << to_string(secret);
  out << ")";
}


AddSecretRequest::~AddSecretRequest() throw() {
}


void AddSecretRequest::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void AddSecretRequest::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void AddSecretRequest::__set_myUserId(const std::string& val) {
  this->myUserId = val;
}

void AddSecretRequest::__set_secretId(const int32_t val) {
  this->secretId = val;
__isset.secretId = true;
}

void AddSecretRequest::__set_ownerGroupId(const int32_t val) {
  this->ownerGroupId = val;
}

void AddSecretRequest::__set_hostname(const std::string& val) {
  this->hostname = val;
}

void AddSecretRequest::__set_encryptedClientData(const std::string& val) {
  this->encryptedClientData = val;
}

void AddSecretRequest::__set_encryptedCriticalData(const std::string& val) {
  this->encryptedCriticalData = val;
}

uint32_t AddSecretRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->myUserId);
          this->__isset.myUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->secretId);
          this->__isset.secretId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ownerGroupId);
          this->__isset.ownerGroupId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hostname);
          this->__isset.hostname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->encryptedClientData);
          this->__isset.encryptedClientData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->encryptedCriticalData);
          this->__isset.encryptedCriticalData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AddSecretRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddSecretRequest");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("myUserId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->myUserId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.secretId) {
    xfer += oprot->writeFieldBegin("secretId", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->secretId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("ownerGroupId", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->ownerGroupId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostname", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->hostname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encryptedClientData", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->encryptedClientData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encryptedCriticalData", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->encryptedCriticalData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddSecretRequest &a, AddSecretRequest &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.myUserId, b.myUserId);
  swap(a.secretId, b.secretId);
  swap(a.ownerGroupId, b.ownerGroupId);
  swap(a.hostname, b.hostname);
  swap(a.encryptedClientData, b.encryptedClientData);
  swap(a.encryptedCriticalData, b.encryptedCriticalData);
  swap(a.__isset, b.__isset);
}

AddSecretRequest::AddSecretRequest(const AddSecretRequest& other92) {
  transactionId = other92.transactionId;
  deviceId = other92.deviceId;
  myUserId = other92.myUserId;
  secretId = other92.secretId;
  ownerGroupId = other92.ownerGroupId;
  hostname = other92.hostname;
  encryptedClientData = other92.encryptedClientData;
  encryptedCriticalData = other92.encryptedCriticalData;
  __isset = other92.__isset;
}
AddSecretRequest& AddSecretRequest::operator=(const AddSecretRequest& other93) {
  transactionId = other93.transactionId;
  deviceId = other93.deviceId;
  myUserId = other93.myUserId;
  secretId = other93.secretId;
  ownerGroupId = other93.ownerGroupId;
  hostname = other93.hostname;
  encryptedClientData = other93.encryptedClientData;
  encryptedCriticalData = other93.encryptedCriticalData;
  __isset = other93.__isset;
  return *this;
}
void AddSecretRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddSecretRequest(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "myUserId=" << to_string(myUserId);
  out << ", " << "secretId="; (__isset.secretId ? (out << to_string(secretId)) : (out << "<null>"));
  out << ", " << "ownerGroupId=" << to_string(ownerGroupId);
  out << ", " << "hostname=" << to_string(hostname);
  out << ", " << "encryptedClientData=" << to_string(encryptedClientData);
  out << ", " << "encryptedCriticalData=" << to_string(encryptedCriticalData);
  out << ")";
}


AddSecretResponse::~AddSecretResponse() throw() {
}


void AddSecretResponse::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void AddSecretResponse::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void AddSecretResponse::__set_secretId(const int32_t val) {
  this->secretId = val;
}

uint32_t AddSecretResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->secretId);
          this->__isset.secretId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AddSecretResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddSecretResponse");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secretId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->secretId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddSecretResponse &a, AddSecretResponse &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.secretId, b.secretId);
  swap(a.__isset, b.__isset);
}

AddSecretResponse::AddSecretResponse(const AddSecretResponse& other94) {
  transactionId = other94.transactionId;
  deviceId = other94.deviceId;
  secretId = other94.secretId;
  __isset = other94.__isset;
}
AddSecretResponse& AddSecretResponse::operator=(const AddSecretResponse& other95) {
  transactionId = other95.transactionId;
  deviceId = other95.deviceId;
  secretId = other95.secretId;
  __isset = other95.__isset;
  return *this;
}
void AddSecretResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddSecretResponse(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "secretId=" << to_string(secretId);
  out << ")";
}


RemoveSecretRequest::~RemoveSecretRequest() throw() {
}


void RemoveSecretRequest::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void RemoveSecretRequest::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void RemoveSecretRequest::__set_myUserId(const std::string& val) {
  this->myUserId = val;
}

void RemoveSecretRequest::__set_groupId(const int32_t val) {
  this->groupId = val;
__isset.groupId = true;
}

void RemoveSecretRequest::__set_secretId(const int32_t val) {
  this->secretId = val;
}

uint32_t RemoveSecretRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->myUserId);
          this->__isset.myUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->groupId);
          this->__isset.groupId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->secretId);
          this->__isset.secretId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RemoveSecretRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RemoveSecretRequest");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("myUserId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->myUserId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.groupId) {
    xfer += oprot->writeFieldBegin("groupId", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->groupId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("secretId", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->secretId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RemoveSecretRequest &a, RemoveSecretRequest &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.myUserId, b.myUserId);
  swap(a.groupId, b.groupId);
  swap(a.secretId, b.secretId);
  swap(a.__isset, b.__isset);
}

RemoveSecretRequest::RemoveSecretRequest(const RemoveSecretRequest& other96) {
  transactionId = other96.transactionId;
  deviceId = other96.deviceId;
  myUserId = other96.myUserId;
  groupId = other96.groupId;
  secretId = other96.secretId;
  __isset = other96.__isset;
}
RemoveSecretRequest& RemoveSecretRequest::operator=(const RemoveSecretRequest& other97) {
  transactionId = other97.transactionId;
  deviceId = other97.deviceId;
  myUserId = other97.myUserId;
  groupId = other97.groupId;
  secretId = other97.secretId;
  __isset = other97.__isset;
  return *this;
}
void RemoveSecretRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RemoveSecretRequest(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "myUserId=" << to_string(myUserId);
  out << ", " << "groupId="; (__isset.groupId ? (out << to_string(groupId)) : (out << "<null>"));
  out << ", " << "secretId=" << to_string(secretId);
  out << ")";
}


EditEncryptedPrivateKeyRequest::~EditEncryptedPrivateKeyRequest() throw() {
}


void EditEncryptedPrivateKeyRequest::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void EditEncryptedPrivateKeyRequest::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void EditEncryptedPrivateKeyRequest::__set_userId(const std::string& val) {
  this->userId = val;
}

void EditEncryptedPrivateKeyRequest::__set_encryptedPrivateKey(const std::string& val) {
  this->encryptedPrivateKey = val;
}

void EditEncryptedPrivateKeyRequest::__set_publicKey(const std::string& val) {
  this->publicKey = val;
}

void EditEncryptedPrivateKeyRequest::__set_analyticsId(const std::string& val) {
  this->analyticsId = val;
}

void EditEncryptedPrivateKeyRequest::__set_groupKeyEncryptedForMe(const std::string& val) {
  this->groupKeyEncryptedForMe = val;
}

void EditEncryptedPrivateKeyRequest::__set_groupPublicKey(const std::string& val) {
  this->groupPublicKey = val;
}

uint32_t EditEncryptedPrivateKeyRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userId);
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->encryptedPrivateKey);
          this->__isset.encryptedPrivateKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->publicKey);
          this->__isset.publicKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->analyticsId);
          this->__isset.analyticsId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupKeyEncryptedForMe);
          this->__isset.groupKeyEncryptedForMe = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupPublicKey);
          this->__isset.groupPublicKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EditEncryptedPrivateKeyRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EditEncryptedPrivateKeyRequest");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encryptedPrivateKey", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->encryptedPrivateKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("publicKey", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->publicKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("analyticsId", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->analyticsId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupKeyEncryptedForMe", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->groupKeyEncryptedForMe);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groupPublicKey", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->groupPublicKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EditEncryptedPrivateKeyRequest &a, EditEncryptedPrivateKeyRequest &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.userId, b.userId);
  swap(a.encryptedPrivateKey, b.encryptedPrivateKey);
  swap(a.publicKey, b.publicKey);
  swap(a.analyticsId, b.analyticsId);
  swap(a.groupKeyEncryptedForMe, b.groupKeyEncryptedForMe);
  swap(a.groupPublicKey, b.groupPublicKey);
  swap(a.__isset, b.__isset);
}

EditEncryptedPrivateKeyRequest::EditEncryptedPrivateKeyRequest(const EditEncryptedPrivateKeyRequest& other98) {
  transactionId = other98.transactionId;
  deviceId = other98.deviceId;
  userId = other98.userId;
  encryptedPrivateKey = other98.encryptedPrivateKey;
  publicKey = other98.publicKey;
  analyticsId = other98.analyticsId;
  groupKeyEncryptedForMe = other98.groupKeyEncryptedForMe;
  groupPublicKey = other98.groupPublicKey;
  __isset = other98.__isset;
}
EditEncryptedPrivateKeyRequest& EditEncryptedPrivateKeyRequest::operator=(const EditEncryptedPrivateKeyRequest& other99) {
  transactionId = other99.transactionId;
  deviceId = other99.deviceId;
  userId = other99.userId;
  encryptedPrivateKey = other99.encryptedPrivateKey;
  publicKey = other99.publicKey;
  analyticsId = other99.analyticsId;
  groupKeyEncryptedForMe = other99.groupKeyEncryptedForMe;
  groupPublicKey = other99.groupPublicKey;
  __isset = other99.__isset;
  return *this;
}
void EditEncryptedPrivateKeyRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EditEncryptedPrivateKeyRequest(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "userId=" << to_string(userId);
  out << ", " << "encryptedPrivateKey=" << to_string(encryptedPrivateKey);
  out << ", " << "publicKey=" << to_string(publicKey);
  out << ", " << "analyticsId=" << to_string(analyticsId);
  out << ", " << "groupKeyEncryptedForMe=" << to_string(groupKeyEncryptedForMe);
  out << ", " << "groupPublicKey=" << to_string(groupPublicKey);
  out << ")";
}


AddIdentityResponse::~AddIdentityResponse() throw() {
}


void AddIdentityResponse::__set_transactionId(const std::string& val) {
  this->transactionId = val;
}

void AddIdentityResponse::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void AddIdentityResponse::__set_unsignedLoginToken(const std::string& val) {
  this->unsignedLoginToken = val;
}

void AddIdentityResponse::__set_verified(const bool val) {
  this->verified = val;
}

void AddIdentityResponse::__set_privateGroupId(const int32_t val) {
  this->privateGroupId = val;
__isset.privateGroupId = true;
}

uint32_t AddIdentityResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->transactionId);
          this->__isset.transactionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unsignedLoginToken);
          this->__isset.unsignedLoginToken = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->verified);
          this->__isset.verified = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->privateGroupId);
          this->__isset.privateGroupId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AddIdentityResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddIdentityResponse");

  xfer += oprot->writeFieldBegin("transactionId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->transactionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unsignedLoginToken", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->unsignedLoginToken);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("verified", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->verified);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.privateGroupId) {
    xfer += oprot->writeFieldBegin("privateGroupId", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->privateGroupId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddIdentityResponse &a, AddIdentityResponse &b) {
  using ::std::swap;
  swap(a.transactionId, b.transactionId);
  swap(a.deviceId, b.deviceId);
  swap(a.unsignedLoginToken, b.unsignedLoginToken);
  swap(a.verified, b.verified);
  swap(a.privateGroupId, b.privateGroupId);
  swap(a.__isset, b.__isset);
}

AddIdentityResponse::AddIdentityResponse(const AddIdentityResponse& other100) {
  transactionId = other100.transactionId;
  deviceId = other100.deviceId;
  unsignedLoginToken = other100.unsignedLoginToken;
  verified = other100.verified;
  privateGroupId = other100.privateGroupId;
  __isset = other100.__isset;
}
AddIdentityResponse& AddIdentityResponse::operator=(const AddIdentityResponse& other101) {
  transactionId = other101.transactionId;
  deviceId = other101.deviceId;
  unsignedLoginToken = other101.unsignedLoginToken;
  verified = other101.verified;
  privateGroupId = other101.privateGroupId;
  __isset = other101.__isset;
  return *this;
}
void AddIdentityResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddIdentityResponse(";
  out << "transactionId=" << to_string(transactionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "unsignedLoginToken=" << to_string(unsignedLoginToken);
  out << ", " << "verified=" << to_string(verified);
  out << ", " << "privateGroupId="; (__isset.privateGroupId ? (out << to_string(privateGroupId)) : (out << "<null>"));
  out << ")";
}

} // namespace
